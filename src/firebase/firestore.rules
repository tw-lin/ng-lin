rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ==========================================
    // Helper Functions (19 functions as documented)
    // ==========================================
    
    /**
     * Check if user is authenticated
     */
    function isAuthenticated() {
      return request.auth != null;
    }
    
    /**
     * Get current account ID from auth token
     */
    function getCurrentAccountId() {
      return request.auth != null ? request.auth.uid : null;
    }
    
    /**
     * Check if current user is blueprint owner
     */
    function isBlueprintOwner(blueprintId) {
      let blueprint = get(/databases/$(database)/documents/blueprints/$(blueprintId));
      let accountId = getCurrentAccountId();
      return blueprint.data.ownerType == 'user' && blueprint.data.ownerId == accountId;
    }
    
    /**
     * Get blueprint owner ID
     */
    function getOwnerId(blueprintId) {
      let blueprint = get(/databases/$(database)/documents/blueprints/$(blueprintId));
      return blueprint.data.ownerId;
    }
    
    /**
     * Get blueprint owner type
     */
    function getOwnerType(blueprintId) {
      let blueprint = get(/databases/$(database)/documents/blueprints/$(blueprintId));
      return blueprint.data.ownerType;
    }
    
    /**
     * Check if user is organization admin
     */
    function isOrganizationAdmin(organizationId) {
      let accountId = getCurrentAccountId();
      let orgDoc = get(/databases/$(database)/documents/organizations/$(organizationId));
      return orgDoc != null && accountId in orgDoc.data.adminIds;
    }
    
    /**
     * Check if user has member role in blueprint
     */
    function hasMemberRole(blueprintId, allowedRoles) {
      let accountId = getCurrentAccountId();
      let memberPath = /databases/$(database)/documents/blueprints/$(blueprintId)/members/$(accountId);
      let member = exists(memberPath) ? get(memberPath) : null;
      return member != null && member.data.role in allowedRoles;
    }
    
    /**
     * Check if user belongs to team with blueprint access
     */
    function hasTeamAccess(blueprintId, requiredAccess) {
      let accountId = getCurrentAccountId();
      // Query would be needed here - simplified for now
      return false;
    }
    
    /**
     * Check if user can read blueprint
     */
    function canReadBlueprint(blueprintId) {
      let ownerType = getOwnerType(blueprintId);
      let ownerId = getOwnerId(blueprintId);
      
      return isBlueprintOwner(blueprintId)
        || (ownerType == 'organization' && isOrganizationAdmin(ownerId))
        || hasMemberRole(blueprintId, ['viewer', 'contributor', 'maintainer'])
        || hasTeamAccess(blueprintId, ['read', 'write', 'admin']);
    }
    
    /**
     * Check if user can edit blueprint
     */
    function canEditBlueprint(blueprintId) {
      let ownerType = getOwnerType(blueprintId);
      let ownerId = getOwnerId(blueprintId);
      
      return isBlueprintOwner(blueprintId)
        || (ownerType == 'organization' && isOrganizationAdmin(ownerId))
        || hasMemberRole(blueprintId, ['maintainer', 'contributor'])
        || hasTeamAccess(blueprintId, ['write', 'admin']);
    }
    
    /**
     * Check if user can delete blueprint
     */
    function canDeleteBlueprint(blueprintId) {
      let ownerType = getOwnerType(blueprintId);
      let ownerId = getOwnerId(blueprintId);
      
      return isBlueprintOwner(blueprintId)
        || (ownerType == 'organization' && isOrganizationAdmin(ownerId));
    }
    
    /**
     * Check if user can manage members
     */
    function canManageMembers(blueprintId) {
      return canEditBlueprint(blueprintId);
    }
    
    /**
     * Check if user can manage settings
     */
    function canManageSettings(blueprintId) {
      let ownerType = getOwnerType(blueprintId);
      let ownerId = getOwnerId(blueprintId);
      
      return isBlueprintOwner(blueprintId)
        || (ownerType == 'organization' && isOrganizationAdmin(ownerId))
        || hasMemberRole(blueprintId, ['maintainer']);
    }
    
    /**
     * Validate blueprint data
     * 
     * Blueprint ownership rules:
     * - Only 'user' and 'organization' can own blueprints
     * - Teams and partners are sub-accounts and cannot own blueprints
     */
    function isValidBlueprintData(data) {
      return data.name is string && data.name.size() >= 3
        && data.slug is string && data.slug.matches('^[a-z0-9-]+$')
        && data.ownerType in ['user', 'organization']
        && data.status in ['draft', 'active', 'archived'];
    }
    
    /**
     * Validate member type is allowed for blueprint owner type
     * 
     * Business Rules:
     * - User-owned blueprints: Only 'user' members allowed (individual collaborators)
     * - Organization-owned blueprints: 'user', 'team', and 'partner' members allowed
     */
    function isValidMemberType(blueprintId, memberType) {
      let ownerType = getOwnerType(blueprintId);
      
      // User-owned blueprints can only have user members
      if (ownerType == 'user') {
        return memberType == 'user';
      }
      
      // Organization-owned blueprints can have all member types
      if (ownerType == 'organization') {
        return memberType in ['user', 'team', 'partner'];
      }
      
      return false;
    }
    
    /**
     * Validate member data consistency
     * 
     * Ensures isExternal flag matches member type:
     * - TEAM members: must have isExternal = false (internal sub-accounts)
     * - PARTNER members: must have isExternal = true (external sub-accounts)
     * - USER members: can be either internal or external
     */
    function isValidMemberData(data) {
      return data.memberType is string
        && data.memberType in ['user', 'team', 'partner']
        && data.accountId is string
        && data.role in ['viewer', 'contributor', 'maintainer']
        && data.isExternal is bool
        // Validate isExternal consistency
        && (data.memberType != 'team' || data.isExternal == false)
        && (data.memberType != 'partner' || data.isExternal == true);
    }
    
    /**
     * Check if update is only soft delete
     */
    function isSoftDelete(before, after) {
      return before.deletedAt == null 
        && after.deletedAt != null
        && after.status == 'archived';
    }
    
    /**
     * Validate contract data
     * 
     * Contract validation rules:
     * - Must have title, contractNumber, owner, contractor
     * - Must have valid status
     * - Must have valid date ranges
     * - totalAmount must be positive number
     */
    function isValidContractData(data) {
      return data.title is string && data.title.size() >= 3
        && data.contractNumber is string && data.contractNumber.matches('^CON-[0-9]+$')
        && data.owner is map
        && data.owner.id is string
        && data.owner.name is string
        && data.owner.type is string
        && data.contractor is map
        && data.contractor.id is string
        && data.contractor.name is string
        && data.contractor.type is string
        && data.totalAmount is number && data.totalAmount >= 0
        && data.currency is string && data.currency.size() == 3
        && data.status in ['draft', 'pending_activation', 'active', 'completed', 'terminated']
        && data.startDate is timestamp
        && data.endDate is timestamp
        && data.createdBy is string
        && data.createdAt is timestamp
        && data.updatedAt is timestamp;
    }
    
    // ==========================================
    // Blueprints Collection Rules
    // ==========================================
    
    match /blueprints/{blueprintId} {
      // Allow create for authenticated users
      allow create: if isAuthenticated()
        && request.resource.data.ownerType in ['user', 'organization']
        && request.resource.data.ownerId == getCurrentAccountId()
        && isValidBlueprintData(request.resource.data);
      
      // Allow read if user has read permission OR blueprint is public
      allow read: if canReadBlueprint(blueprintId) 
        || resource.data.isPublic == true;
      
      // Allow update if user has edit permission (excluding deletedAt field)
      allow update: if canEditBlueprint(blueprintId)
        && isValidBlueprintData(request.resource.data)
        && request.resource.data.deletedAt == resource.data.deletedAt;
      
      // Allow soft delete (setting deletedAt field)
      allow update: if canDeleteBlueprint(blueprintId)
        && isSoftDelete(resource.data, request.resource.data);
      
      // Members subcollection
      match /members/{memberId} {
        allow read: if canReadBlueprint(blueprintId);
        allow create: if canManageMembers(blueprintId)
          && request.resource.data.blueprintId == blueprintId
          && isValidMemberData(request.resource.data)
          && isValidMemberType(blueprintId, request.resource.data.memberType);
        allow update: if canManageMembers(blueprintId)
          && isValidMemberData(request.resource.data);
        allow delete: if canManageMembers(blueprintId);
      }
      
      // Team roles subcollection
      match /teamRoles/{teamId} {
        allow read: if canReadBlueprint(blueprintId);
        allow write: if canManageSettings(blueprintId);
      }
      
      // Modules subcollection (Blueprint V2)
      match /modules/{moduleId} {
        allow read: if canReadBlueprint(blueprintId);
        allow create, update: if canManageSettings(blueprintId)
          && request.resource.data.moduleType is string
          && request.resource.data.name is string
          && request.resource.data.version is string;
        allow delete: if canManageSettings(blueprintId);
      }
      
      // Audit logs subcollection (read-only for users, write via service)
      match /audit-logs/{logId} {
        allow read: if canReadBlueprint(blueprintId);
        allow create: if canEditBlueprint(blueprintId)
          && request.resource.data.eventType is string
          && request.resource.data.category is string
          && request.resource.data.actorId is string;
        allow update, delete: if false; // Immutable
      }
      
      // Legacy audit logs path (deprecated, use audit-logs)
      match /auditLogs/{logId} {
        allow read: if canReadBlueprint(blueprintId);
        allow create: if false; // Only via Cloud Functions
        allow update, delete: if false; // Immutable
      }
      
      // Events subcollection
      match /events/{eventId} {
        allow read: if canReadBlueprint(blueprintId);
        allow create: if canEditBlueprint(blueprintId);
        allow update, delete: if false; // Events are immutable
      }
      
      // Configuration subcollection
      match /configuration/{configId} {
        allow read: if canReadBlueprint(blueprintId);
        allow write: if canManageSettings(blueprintId);
      }
      
      // Module data subcollections
      match /tasks/{taskId} {
        allow read: if canReadBlueprint(blueprintId);
        allow create, update, delete: if canEditBlueprint(blueprintId);
      }
      
      match /logs/{logId} {
        allow read: if canReadBlueprint(blueprintId);
        allow create, update, delete: if canEditBlueprint(blueprintId);
      }
      
      match /quality/{qualityId} {
        allow read: if canReadBlueprint(blueprintId);
        allow create, update, delete: if canEditBlueprint(blueprintId);
      }
      
      // ==========================================
      // Contracts Subcollection Rules
      // ==========================================
      
      /**
       * Contracts are stored as subcollections under blueprints
       * Path: /blueprints/{blueprintId}/contracts/{contractId}
       * 
       * Access Control:
       * - Read: Users with blueprint read permission
       * - Create: Users with blueprint edit permission
       * - Update: Users with blueprint edit permission OR contract creator
       * - Delete: Blueprint owners and maintainers only
       */
      match /contracts/{contractId} {
        // Allow read if user can read the blueprint
        allow read: if canReadBlueprint(blueprintId);
        
        // Allow create if user can edit the blueprint
        allow create: if canEditBlueprint(blueprintId)
          && request.resource.data.blueprintId == blueprintId
          && request.resource.data.createdBy == getCurrentAccountId()
          && isValidContractData(request.resource.data);
        
        // Allow update if user can edit the blueprint OR is the contract creator
        allow update: if (canEditBlueprint(blueprintId) 
                         || resource.data.createdBy == getCurrentAccountId())
          && request.resource.data.blueprintId == blueprintId
          && isValidContractData(request.resource.data);
        
        // Allow delete only for blueprint owners and maintainers
        allow delete: if isBlueprintOwner(blueprintId) 
                      || hasMemberRole(blueprintId, ['maintainer']);
        
        /**
         * Work Items Subcollection
         * Path: /blueprints/{blueprintId}/contracts/{contractId}/workItems/{workItemId}
         */
        match /workItems/{workItemId} {
          // Read access follows contract read permission
          allow read: if canReadBlueprint(blueprintId);
          
          // Write access requires blueprint edit permission
          allow create, update: if canEditBlueprint(blueprintId)
            && request.resource.data.contractId == contractId;
          
          // Delete requires blueprint edit permission
          allow delete: if canEditBlueprint(blueprintId);
        }
        
        /**
         * Parsing Requests Subcollection
         * Path: /blueprints/{blueprintId}/contracts/{contractId}/parsingRequests/{requestId}
         * 
         * These are AI parsing request records for contract documents
         */
        match /parsingRequests/{requestId} {
          // Read access follows contract read permission
          allow read: if canReadBlueprint(blueprintId);
          
          // Create requires edit permission (triggering AI parsing)
          allow create: if canEditBlueprint(blueprintId)
            && request.resource.data.contractId == contractId
            && request.resource.data.requestedBy == getCurrentAccountId();
          
          // Update for status changes (Cloud Functions can update via service account)
          allow update: if canEditBlueprint(blueprintId);
          
          // Delete not allowed (maintain audit trail)
          allow delete: if false;
        }
      }
    }
    
    // ==========================================
    // Accounts Collection Rules
    // ==========================================
    
    match /accounts/{accountId} {
      // Users can read their own account
      allow read: if isAuthenticated() && getCurrentAccountId() == accountId;
      
      // Authenticated users can read discoverable accounts (for explore/search)
      allow get: if isAuthenticated() 
        && (getCurrentAccountId() == accountId 
            || resource.data.is_discoverable != false);
      
      allow create: if isAuthenticated() && getCurrentAccountId() == accountId;
      allow update: if isAuthenticated() && getCurrentAccountId() == accountId;
    }
    
    // ==========================================
    // Organizations Collection Rules
    // ==========================================
    
    match /organizations/{organizationId} {
      // Authenticated users can read discoverable organizations (for explore/search)
      // or organizations they are members of
      allow read: if isAuthenticated() 
        && (resource.data.is_discoverable != false 
            || isOrganizationAdmin(organizationId));
      
      allow create: if isAuthenticated();
      allow update, delete: if isOrganizationAdmin(organizationId);
      
      match /members/{memberId} {
        allow read: if isAuthenticated();
        allow write: if isOrganizationAdmin(organizationId);
      }
    }
    
    // ==========================================
    // Teams Collection Rules
    // ==========================================
    
    match /teams/{teamId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated();
      
      match /members/{memberId} {
        allow read: if isAuthenticated();
        allow write: if isAuthenticated();
      }
    }
    
    // ==========================================
    // Partners Collection Rules
    // ==========================================
    
    match /partners/{partnerId} {
      // Users can read partners in their organization
      allow read: if isAuthenticated();
      
      // Users can create partners in their organization
      allow create: if isAuthenticated()
        && request.resource.data.organization_id is string
        && request.resource.data.name is string
        && request.resource.data.type in ['contractor', 'supplier', 'consultant', 'subcontractor'];
      
      // Users can update partners in their organization
      allow update: if isAuthenticated()
        && resource.data.organization_id == request.resource.data.organization_id;
      
      // Users can delete partners in their organization
      allow delete: if isAuthenticated();
    }
    
    // ==========================================
    // Partner Members Collection Rules
    // ==========================================
    
    match /partner_members/{memberId} {
      // Users can read partner members
      allow read: if isAuthenticated();
      
      // Users can create partner members
      allow create: if isAuthenticated()
        && request.resource.data.partner_id is string
        && request.resource.data.user_id is string
        && request.resource.data.role in ['admin', 'member'];
      
      // Users can update partner members (role changes)
      allow update: if isAuthenticated();
      
      // Users can delete partner members
      allow delete: if isAuthenticated();
    }
    
    // ==========================================
    // Tasks Collection Rules (Top-Level)
    // ==========================================
    
    match /tasks/{taskId} {
      // Allow read if user can read the associated blueprint
      allow read: if isAuthenticated() 
        && canReadBlueprint(resource.data.blueprint_id);
      
      // Allow create if user can edit the blueprint
      allow create: if isAuthenticated()
        && canEditBlueprint(request.resource.data.blueprint_id)
        && request.resource.data.creator_id == getCurrentAccountId();
      
      // Allow update if user can edit the blueprint
      allow update: if isAuthenticated()
        && canEditBlueprint(resource.data.blueprint_id);
      
      // Allow delete if user can edit the blueprint
      allow delete: if isAuthenticated()
        && canDeleteBlueprint(resource.data.blueprint_id);
    }
    
    // ==========================================
    // Logs Collection Rules (Top-Level)
    // ==========================================
    
    match /logs/{logId} {
      // Allow read if user can read the associated blueprint
      allow read: if isAuthenticated()
        && canReadBlueprint(resource.data.blueprint_id);
      
      // Allow create if user can edit the blueprint
      allow create: if isAuthenticated()
        && canEditBlueprint(request.resource.data.blueprint_id)
        && request.resource.data.creator_id == getCurrentAccountId();
      
      // Allow update if user can edit the blueprint
      allow update: if isAuthenticated()
        && canEditBlueprint(resource.data.blueprint_id);
      
      // Allow delete if user can edit the blueprint
      allow delete: if isAuthenticated()
        && canDeleteBlueprint(resource.data.blueprint_id);
    }
    
    // ==========================================
    // Cloud Files Collection Rules (Top-Level)
    // ==========================================
    
    match /cloud_files/{fileId} {
      // Allow read if user can read the associated blueprint
      allow read: if isAuthenticated()
        && canReadBlueprint(resource.data.blueprint_id);
      
      // Allow create if user can edit the blueprint
      allow create: if isAuthenticated()
        && canEditBlueprint(request.resource.data.blueprint_id)
        && request.resource.data.uploaded_by == getCurrentAccountId()
        && request.resource.data.name is string
        && request.resource.data.path is string
        && request.resource.data.size is number;
      
      // Allow update if user can edit the blueprint
      allow update: if isAuthenticated()
        && canEditBlueprint(resource.data.blueprint_id);
      
      // Allow delete if user can edit the blueprint
      allow delete: if isAuthenticated()
        && canEditBlueprint(resource.data.blueprint_id);
    }
    
    // ==========================================
    // Cloud Backups Collection Rules (Top-Level)
    // ==========================================
    
    match /cloud_backups/{backupId} {
      // Allow read if user can read the associated blueprint
      allow read: if isAuthenticated()
        && canReadBlueprint(resource.data.blueprint_id);
      
      // Allow create if user can edit the blueprint
      allow create: if isAuthenticated()
        && canEditBlueprint(request.resource.data.blueprint_id)
        && request.resource.data.created_by == getCurrentAccountId()
        && request.resource.data.name is string
        && request.resource.data.type in ['manual', 'automatic', 'scheduled']
        && request.resource.data.status in ['creating', 'ready', 'restoring', 'error'];
      
      // Allow update if user can edit the blueprint (for status changes)
      allow update: if isAuthenticated()
        && canEditBlueprint(resource.data.blueprint_id)
        && request.resource.data.status in ['creating', 'ready', 'restoring', 'error'];
      
      // Allow delete if user can delete the blueprint
      allow delete: if isAuthenticated()
        && canDeleteBlueprint(resource.data.blueprint_id);
    }
    
    // ==========================================
    // Notifications Collection Rules
    // ==========================================
    
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if isAuthenticated() 
        && resource.data.userId == getCurrentAccountId();
      
      // Users can update their own notifications (mark as read, delete)
      allow update: if isAuthenticated() 
        && resource.data.userId == getCurrentAccountId()
        && request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['read', 'updatedAt']);
      
      // Users can delete their own notifications
      allow delete: if isAuthenticated() 
        && resource.data.userId == getCurrentAccountId();
      
      // Only backend (via Admin SDK) can create notifications
      // Or Cloud Functions with service account
      allow create: if false;
    }
    
    // ==========================================
    // FCM Tokens Collection Rules
    // ==========================================
    
    match /fcm_tokens/{userId} {
      // Users can read, create, and update their own FCM token
      allow read, create, update: if isAuthenticated() 
        && userId == getCurrentAccountId();
      
      // Users can delete their own token
      allow delete: if isAuthenticated() 
        && userId == getCurrentAccountId();
    }
    
    // ==========================================
    // Friend Relations Collection Rules
    // ==========================================
    
    match /friend_relations/{relationId} {
      // Users can read friend relations where they are requester or recipient
      allow read: if isAuthenticated() 
        && (resource.data.requesterId == getCurrentAccountId()
            || resource.data.recipientId == getCurrentAccountId());
      
      // Users can create friend requests as requester
      allow create: if isAuthenticated()
        && request.resource.data.requesterId == getCurrentAccountId()
        && request.resource.data.status == 'pending';
      
      // Users can update friend relations where they are requester or recipient
      // (accept/reject/block)
      allow update: if isAuthenticated()
        && (resource.data.requesterId == getCurrentAccountId()
            || resource.data.recipientId == getCurrentAccountId())
        && request.resource.data.status in ['accepted', 'rejected', 'blocked'];
      
      // Users can delete friend relations where they are requester or recipient
      allow delete: if isAuthenticated()
        && (resource.data.requesterId == getCurrentAccountId()
            || resource.data.recipientId == getCurrentAccountId());
    }
    
    // ==========================================
    // Notification Preferences Collection Rules
    // ==========================================
    
    match /notification_preferences/{userId} {
      // Users can read, create, and update their own preferences
      allow read, create, update: if isAuthenticated() 
        && userId == getCurrentAccountId();
      
      // Users can delete their own preferences
      allow delete: if isAuthenticated() 
        && userId == getCurrentAccountId();
    }
    
    // ==========================================
    // Global Audit Logs Collection Rules
    // Phase 1 (P0) - Task 1.2 (Tenant Isolation)
    // ==========================================
    
    /**
     * Get user's tenant ID from auth token
     */
    function getUserTenantId() {
      return request.auth.token.tenant_id;
    }
    
    /**
     * Check if user belongs to specified tenant
     */
    function belongsToTenant(tenantId) {
      return isAuthenticated() && getUserTenantId() == tenantId;
    }
    
    /**
     * Check if user is superadmin
     * Superadmins can read across all tenants
     */
    function isSuperAdmin() {
      return isAuthenticated() && 
             request.auth.token.role == 'superadmin';
    }
    
    /**
     * Check if user can read audit event
     * - User must belong to same tenant OR be superadmin
     */
    function canReadAuditEvent(event) {
      return belongsToTenant(event.tenant_id) || isSuperAdmin();
    }
    
    /**
     * Validate audit event write data
     * - Must include tenant_id
     * - tenant_id must match user's tenant (unless superadmin)
     * - Required fields must be present
     */
    function isValidAuditEventWrite() {
      let data = request.resource.data;
      
      return data.keys().hasAll([
        'event_id', 'tenant_id', 'timestamp', 'level', 'category',
        'actor_id', 'resource_type', 'resource_id', 'action',
        'result', 'description', 'requires_review', 'created_at'
      ]) &&
      // Tenant isolation: tenant_id must match user's tenant
      (belongsToTenant(data.tenant_id) || isSuperAdmin()) &&
      // Validate field types
      data.tenant_id is string &&
      data.event_id is string &&
      data.timestamp is timestamp &&
      data.level in ['INFO', 'WARNING', 'ERROR', 'CRITICAL'] &&
      data.category in [
        'AUTHENTICATION', 'AUTHORIZATION', 'DATA_ACCESS', 
        'DATA_MODIFICATION', 'SECURITY', 'SYSTEM_CONFIGURATION',
        'COMPLIANCE', 'BUSINESS_OPERATION'
      ] &&
      data.actor_id is string &&
      data.resource_type is string &&
      data.resource_id is string &&
      data.action is string &&
      data.result in ['success', 'failure', 'partial'] &&
      data.description is string &&
      data.requires_review is bool &&
      data.created_at is timestamp;
    }
    
    /**
     * Check if user can review audit events
     * - Must be security reviewer or compliance officer
     */
    function canReviewAuditEvents() {
      return isAuthenticated() && (
        request.auth.token.role == 'security_reviewer' ||
        request.auth.token.role == 'compliance_officer' ||
        isSuperAdmin()
      );
    }
    
    match /audit_logs/{auditEventId} {
      
      /**
       * READ Rules
       * - Authenticated users can read events from their tenant
       * - Superadmins can read all events
       */
      allow read: if isAuthenticated() && 
                     canReadAuditEvent(resource.data);
      
      /**
       * CREATE Rules
       * - Authenticated users can create audit events for their tenant
       * - Must pass validation (tenant_id, required fields, types)
       * - Superadmins can create events for any tenant
       */
      allow create: if isAuthenticated() && 
                       isValidAuditEventWrite();
      
      /**
       * UPDATE Rules
       * - Only allow updating review fields (reviewed_at, reviewed_by, review_notes)
       * - User must have reviewer role
       * - Cannot modify core audit data (immutable)
       * - Must belong to same tenant
       */
      allow update: if isAuthenticated() &&
                       canReviewAuditEvents() &&
                       canReadAuditEvent(resource.data) &&
                       // Only allow updating review fields
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['reviewed_at', 'reviewed_by', 'review_notes']) &&
                       // Ensure review fields are valid
                       request.resource.data.reviewed_at is timestamp &&
                       request.resource.data.reviewed_by is string;
      
      /**
       * DELETE Rules
       * - Audit events are immutable (cannot be deleted)
       * - Use retention policies and archiving instead
       * - Exception: Superadmins can delete for compliance (GDPR, data retention)
       */
      allow delete: if isSuperAdmin();
    }
  }
}
